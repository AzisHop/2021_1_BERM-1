
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">user/api/api.pb.go (14.5%)</option>
				
				<option value="file1">user/api/api_grpc.pb.go (0.0%)</option>
				
				<option value="file2">user/api/order.pb.go (11.7%)</option>
				
				<option value="file3">user/api/order_grpc.pb.go (0.0%)</option>
				
				<option value="file4">user/api/user.pb.go (3.5%)</option>
				
				<option value="file5">user/api/user_grpc.pb.go (0.0%)</option>
				
				<option value="file6">user/cmd/main.go (1.3%)</option>
				
				<option value="file7">user/configs/config.go (0.0%)</option>
				
				<option value="file8">user/internal/app/order/mock/mock_repository.go (100.0%)</option>
				
				<option value="file9">user/internal/app/order/repository/repository.go (0.0%)</option>
				
				<option value="file10">user/internal/app/review/handlers/httphandlers.go (0.0%)</option>
				
				<option value="file11">user/internal/app/review/mock/mock_repository.go (100.0%)</option>
				
				<option value="file12">user/internal/app/review/repository/repository.go (0.0%)</option>
				
				<option value="file13">user/internal/app/review/usecase/usecase.go (75.0%)</option>
				
				<option value="file14">user/internal/app/session/handlers/handlers.go (0.0%)</option>
				
				<option value="file15">user/internal/app/session/mock/mock_repository.go (100.0%)</option>
				
				<option value="file16">user/internal/app/session/repository/repository.go (0.0%)</option>
				
				<option value="file17">user/internal/app/session/usecase/usecase.go (60.0%)</option>
				
				<option value="file18">user/internal/app/specialize/handler/httphandlers.go (0.0%)</option>
				
				<option value="file19">user/internal/app/specialize/mock/mock_repository.go (100.0%)</option>
				
				<option value="file20">user/internal/app/specialize/repository/repository.go (0.0%)</option>
				
				<option value="file21">user/internal/app/specialize/usecase/usecase.go (80.0%)</option>
				
				<option value="file22">user/internal/app/user/handlers/grpchandlers.go (0.0%)</option>
				
				<option value="file23">user/internal/app/user/handlers/httphandlers.go (0.0%)</option>
				
				<option value="file24">user/internal/app/user/mock/mock_repository.go (83.8%)</option>
				
				<option value="file25">user/internal/app/user/mock/mock_usecase.go (0.0%)</option>
				
				<option value="file26">user/internal/app/user/repository/repository.go (0.0%)</option>
				
				<option value="file27">user/internal/app/user/tools/password.go (90.9%)</option>
				
				<option value="file28">user/internal/app/user/tools/validation.go (87.5%)</option>
				
				<option value="file29">user/internal/app/user/usecase/usecase.go (75.0%)</option>
				
				<option value="file30">user/pkg/database/postgresql/postgres.go (0.0%)</option>
				
				<option value="file31">user/pkg/error/errortools/grpcerror.go (0.0%)</option>
				
				<option value="file32">user/pkg/error/errortools/sqlerror.go (0.0%)</option>
				
				<option value="file33">user/pkg/error/errortools/tools.go (0.0%)</option>
				
				<option value="file34">user/pkg/error/errortools/validationerror.go (0.0%)</option>
				
				<option value="file35">user/pkg/httputils/httputils.go (0.0%)</option>
				
				<option value="file36">user/pkg/logger/loger.go (0.0%)</option>
				
				<option value="file37">user/pkg/metric/metric.go (0.0%)</option>
				
				<option value="file38">user/pkg/middleware/middleware.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.26.0
//         protoc        v3.15.8
// source: api.proto

package api

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SessionCheckRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SessionId string `protobuf:"bytes,1,opt,name=sessionId,proto3" json:"sessionId,omitempty"`
}

func (x *SessionCheckRequest) Reset() <span class="cov0" title="0">{
        *x = SessionCheckRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SessionCheckRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SessionCheckRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SessionCheckRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SessionCheckRequest.ProtoReflect.Descriptor instead.
func (*SessionCheckRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_rawDescGZIP(), []int{0}
}</span>

func (x *SessionCheckRequest) GetSessionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SessionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SessionCheckResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ID       uint64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
        Executor bool   `protobuf:"varint,2,opt,name=executor,proto3" json:"executor,omitempty"`
}

func (x *SessionCheckResponse) Reset() <span class="cov0" title="0">{
        *x = SessionCheckResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SessionCheckResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SessionCheckResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SessionCheckResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SessionCheckResponse.ProtoReflect.Descriptor instead.
func (*SessionCheckResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_rawDescGZIP(), []int{1}
}</span>

func (x *SessionCheckResponse) GetID() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SessionCheckResponse) GetExecutor() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Executor
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_api_proto protoreflect.FileDescriptor

var file_api_proto_rawDesc = []byte{
        0x0a, 0x09, 0x61, 0x70, 0x69, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x33, 0x0a, 0x13, 0x53,
        0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64,
        0x22, 0x42, 0x0a, 0x14, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x43, 0x68, 0x65, 0x63, 0x6b,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x49, 0x44, 0x12, 0x1a, 0x0a, 0x08, 0x65, 0x78, 0x65, 0x63,
        0x75, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x65, 0x78, 0x65, 0x63,
        0x75, 0x74, 0x6f, 0x72, 0x32, 0x41, 0x0a, 0x07, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12,
        0x36, 0x0a, 0x05, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x14, 0x2e, 0x53, 0x65, 0x73, 0x73, 0x69,
        0x6f, 0x6e, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x15,
        0x2e, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x07, 0x5a, 0x05, 0x2e, 0x2f, 0x61, 0x70, 0x69,
        0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_api_proto_rawDescOnce sync.Once
        file_api_proto_rawDescData = file_api_proto_rawDesc
)

func file_api_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_proto_rawDescData = protoimpl.X.CompressGZIP(file_api_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_api_proto_rawDescData</span>
}

var file_api_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_api_proto_goTypes = []interface{}{
        (*SessionCheckRequest)(nil),  // 0: SessionCheckRequest
        (*SessionCheckResponse)(nil), // 1: SessionCheckResponse
}
var file_api_proto_depIdxs = []int32{
        0, // 0: Session.Check:input_type -&gt; SessionCheckRequest
        1, // 1: Session.Check:output_type -&gt; SessionCheckResponse
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_api_proto_init() }</span>
func file_api_proto_init() <span class="cov8" title="1">{
        if File_api_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_api_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SessionCheckRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SessionCheckResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_api_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_proto_goTypes,
                DependencyIndexes: file_api_proto_depIdxs,
                MessageInfos:      file_api_proto_msgTypes,
        }.Build()
        File_api_proto = out.File
        file_api_proto_rawDesc = nil
        file_api_proto_goTypes = nil
        file_api_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package api

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SessionClient is the client API for Session service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionClient interface {
        Check(ctx context.Context, in *SessionCheckRequest, opts ...grpc.CallOption) (*SessionCheckResponse, error)
}

type sessionClient struct {
        cc grpc.ClientConnInterface
}

func NewSessionClient(cc grpc.ClientConnInterface) SessionClient <span class="cov0" title="0">{
        return &amp;sessionClient{cc}
}</span>

func (c *sessionClient) Check(ctx context.Context, in *SessionCheckRequest, opts ...grpc.CallOption) (*SessionCheckResponse, error) <span class="cov0" title="0">{
        out := new(SessionCheckResponse)
        err := c.cc.Invoke(ctx, "/Session/Check", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// SessionServer is the server API for Session service.
// All implementations must embed UnimplementedSessionServer
// for forward compatibility
type SessionServer interface {
        Check(context.Context, *SessionCheckRequest) (*SessionCheckResponse, error)
        mustEmbedUnimplementedSessionServer()
}

// UnimplementedSessionServer must be embedded to have forward compatible implementations.
type UnimplementedSessionServer struct {
}

func (UnimplementedSessionServer) Check(context.Context, *SessionCheckRequest) (*SessionCheckResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Check not implemented")
}</span>
func (UnimplementedSessionServer) mustEmbedUnimplementedSessionServer() {<span class="cov0" title="0">}</span>

// UnsafeSessionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionServer will
// result in compilation errors.
type UnsafeSessionServer interface {
        mustEmbedUnimplementedSessionServer()
}

func RegisterSessionServer(s grpc.ServiceRegistrar, srv SessionServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;Session_ServiceDesc, srv)
}</span>

func _Session_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SessionCheckRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(SessionServer).Check(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/Session/Check",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(SessionServer).Check(ctx, req.(*SessionCheckRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Session_ServiceDesc is the grpc.ServiceDesc for Session service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Session_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "Session",
        HandlerType: (*SessionServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Check",
                        Handler:    _Session_Check_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "api.proto",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.26.0
//         protoc        v3.15.8
// source: order.proto

package api

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type OrderRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *OrderRequest) Reset() <span class="cov0" title="0">{
        *x = OrderRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_order_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OrderRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_order_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderRequest.ProtoReflect.Descriptor instead.
func (*OrderRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_order_proto_rawDescGZIP(), []int{0}
}</span>

func (x *OrderRequest) GetId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type OrderInfoResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        OrderName   string `protobuf:"bytes,1,opt,name=orderName,proto3" json:"orderName,omitempty"`
        CustomerID  uint64 `protobuf:"varint,2,opt,name=customerID,proto3" json:"customerID,omitempty"`
        ExecutorID  uint64 `protobuf:"varint,3,opt,name=executorID,proto3" json:"executorID,omitempty"`
        Budget      uint64 `protobuf:"varint,4,opt,name=budget,proto3" json:"budget,omitempty"`
        Deadline    uint64 `protobuf:"varint,5,opt,name=deadline,proto3" json:"deadline,omitempty"`
        Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
        Category    string `protobuf:"bytes,7,opt,name=category,proto3" json:"category,omitempty"`
}

func (x *OrderInfoResponse) Reset() <span class="cov0" title="0">{
        *x = OrderInfoResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_order_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OrderInfoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OrderInfoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OrderInfoResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_order_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OrderInfoResponse.ProtoReflect.Descriptor instead.
func (*OrderInfoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_order_proto_rawDescGZIP(), []int{1}
}</span>

func (x *OrderInfoResponse) GetOrderName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OrderName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *OrderInfoResponse) GetCustomerID() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CustomerID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *OrderInfoResponse) GetExecutorID() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExecutorID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *OrderInfoResponse) GetBudget() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Budget
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *OrderInfoResponse) GetDeadline() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Deadline
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *OrderInfoResponse) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *OrderInfoResponse) GetCategory() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Category
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_order_proto protoreflect.FileDescriptor

var file_order_proto_rawDesc = []byte{
        0x0a, 0x0b, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x1e, 0x0a,
        0x0c, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a,
        0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64, 0x22, 0xe3, 0x01,
        0x0a, 0x11, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x4e, 0x61, 0x6d,
        0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x65, 0x72, 0x49, 0x44, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x65, 0x72, 0x49,
        0x44, 0x12, 0x1e, 0x0a, 0x0a, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x44, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0a, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49,
        0x44, 0x12, 0x16, 0x0a, 0x06, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28,
        0x04, 0x52, 0x06, 0x62, 0x75, 0x64, 0x67, 0x65, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x65, 0x61,
        0x64, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x64, 0x65, 0x61,
        0x64, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63,
        0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x61, 0x74, 0x65, 0x67,
        0x6f, 0x72, 0x79, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x61, 0x74, 0x65, 0x67,
        0x6f, 0x72, 0x79, 0x32, 0x3c, 0x0a, 0x05, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x33, 0x0a, 0x0c,
        0x47, 0x65, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x42, 0x79, 0x49, 0x64, 0x12, 0x0d, 0x2e, 0x4f,
        0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x12, 0x2e, 0x4f, 0x72,
        0x64, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
        0x00, 0x42, 0x07, 0x5a, 0x05, 0x2e, 0x2f, 0x61, 0x70, 0x69, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x33,
}

var (
        file_order_proto_rawDescOnce sync.Once
        file_order_proto_rawDescData = file_order_proto_rawDesc
)

func file_order_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_order_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_order_proto_rawDescData = protoimpl.X.CompressGZIP(file_order_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_order_proto_rawDescData</span>
}

var file_order_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_order_proto_goTypes = []interface{}{
        (*OrderRequest)(nil),      // 0: OrderRequest
        (*OrderInfoResponse)(nil), // 1: OrderInfoResponse
}
var file_order_proto_depIdxs = []int32{
        0, // 0: Order.GetOrderById:input_type -&gt; OrderRequest
        1, // 1: Order.GetOrderById:output_type -&gt; OrderInfoResponse
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_order_proto_init() }</span>
func file_order_proto_init() <span class="cov8" title="1">{
        if File_order_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_order_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*OrderRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_order_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*OrderInfoResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_order_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_order_proto_goTypes,
                DependencyIndexes: file_order_proto_depIdxs,
                MessageInfos:      file_order_proto_msgTypes,
        }.Build()
        File_order_proto = out.File
        file_order_proto_rawDesc = nil
        file_order_proto_goTypes = nil
        file_order_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package api

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// OrderClient is the client API for Order service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrderClient interface {
        GetOrderById(ctx context.Context, in *OrderRequest, opts ...grpc.CallOption) (*OrderInfoResponse, error)
}

type orderClient struct {
        cc grpc.ClientConnInterface
}

func NewOrderClient(cc grpc.ClientConnInterface) OrderClient <span class="cov0" title="0">{
        return &amp;orderClient{cc}
}</span>

func (c *orderClient) GetOrderById(ctx context.Context, in *OrderRequest, opts ...grpc.CallOption) (*OrderInfoResponse, error) <span class="cov0" title="0">{
        out := new(OrderInfoResponse)
        err := c.cc.Invoke(ctx, "/Order/GetOrderById", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// OrderServer is the server API for Order service.
// All implementations must embed UnimplementedOrderServer
// for forward compatibility
type OrderServer interface {
        GetOrderById(context.Context, *OrderRequest) (*OrderInfoResponse, error)
        mustEmbedUnimplementedOrderServer()
}

// UnimplementedOrderServer must be embedded to have forward compatible implementations.
type UnimplementedOrderServer struct {
}

func (UnimplementedOrderServer) GetOrderById(context.Context, *OrderRequest) (*OrderInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetOrderById not implemented")
}</span>
func (UnimplementedOrderServer) mustEmbedUnimplementedOrderServer() {<span class="cov0" title="0">}</span>

// UnsafeOrderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrderServer will
// result in compilation errors.
type UnsafeOrderServer interface {
        mustEmbedUnimplementedOrderServer()
}

func RegisterOrderServer(s grpc.ServiceRegistrar, srv OrderServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;Order_ServiceDesc, srv)
}</span>

func _Order_GetOrderById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(OrderRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OrderServer).GetOrderById(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/Order/GetOrderById",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OrderServer).GetOrderById(ctx, req.(*OrderRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Order_ServiceDesc is the grpc.ServiceDesc for Order service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Order_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "Order",
        HandlerType: (*OrderServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetOrderById",
                        Handler:    _Order_GetOrderById_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "order.proto",
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.26.0
//         protoc        v3.15.8
// source: user.proto

package api

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type NewUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Email       string   `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        Login       string   `protobuf:"bytes,2,opt,name=login,proto3" json:"login,omitempty"`
        NameSurname string   `protobuf:"bytes,3,opt,name=nameSurname,proto3" json:"nameSurname,omitempty"`
        Password    string   `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
        About       string   `protobuf:"bytes,5,opt,name=about,proto3" json:"about,omitempty"`
        Specializes []string `protobuf:"bytes,6,rep,name=specializes,proto3" json:"specializes,omitempty"`
        ReqId       uint64   `protobuf:"varint,7,opt,name=reqId,proto3" json:"reqId,omitempty"`
}

func (x *NewUserRequest) Reset() <span class="cov0" title="0">{
        *x = NewUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *NewUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*NewUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *NewUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use NewUserRequest.ProtoReflect.Descriptor instead.
func (*NewUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{0}
}</span>

func (x *NewUserRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NewUserRequest) GetLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Login
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NewUserRequest) GetNameSurname() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NameSurname
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NewUserRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NewUserRequest) GetAbout() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.About
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NewUserRequest) GetSpecializes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Specializes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *NewUserRequest) GetReqId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReqId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UserResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id       uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Executor bool   `protobuf:"varint,2,opt,name=executor,proto3" json:"executor,omitempty"`
}

func (x *UserResponse) Reset() <span class="cov0" title="0">{
        *x = UserResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserResponse.ProtoReflect.Descriptor instead.
func (*UserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{1}
}</span>

func (x *UserResponse) GetId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserResponse) GetExecutor() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Executor
        }</span>
        <span class="cov0" title="0">return false</span>
}

type AuthorizationUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Email    string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
        ReqId    uint64 `protobuf:"varint,3,opt,name=reqId,proto3" json:"reqId,omitempty"`
}

func (x *AuthorizationUserRequest) Reset() <span class="cov0" title="0">{
        *x = AuthorizationUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AuthorizationUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AuthorizationUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AuthorizationUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AuthorizationUserRequest.ProtoReflect.Descriptor instead.
func (*AuthorizationUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{2}
}</span>

func (x *AuthorizationUserRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthorizationUserRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AuthorizationUserRequest) GetReqId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReqId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id    uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        ReqId uint64 `protobuf:"varint,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
}

func (x *UserRequest) Reset() <span class="cov0" title="0">{
        *x = UserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserRequest.ProtoReflect.Descriptor instead.
func (*UserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{3}
}</span>

func (x *UserRequest) GetId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserRequest) GetReqId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReqId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UserInfoResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Email       string   `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        Login       string   `protobuf:"bytes,2,opt,name=login,proto3" json:"login,omitempty"`
        NameSurname string   `protobuf:"bytes,3,opt,name=nameSurname,proto3" json:"nameSurname,omitempty"`
        About       string   `protobuf:"bytes,4,opt,name=about,proto3" json:"about,omitempty"`
        Specializes []string `protobuf:"bytes,5,rep,name=specializes,proto3" json:"specializes,omitempty"`
        Executor    bool     `protobuf:"varint,6,opt,name=executor,proto3" json:"executor,omitempty"`
        Img         string   `protobuf:"bytes,7,opt,name=img,proto3" json:"img,omitempty"`
        Rating      int32    `protobuf:"varint,8,opt,name=rating,proto3" json:"rating,omitempty"`
}

func (x *UserInfoResponse) Reset() <span class="cov0" title="0">{
        *x = UserInfoResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UserInfoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserInfoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserInfoResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserInfoResponse.ProtoReflect.Descriptor instead.
func (*UserInfoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{4}
}</span>

func (x *UserInfoResponse) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserInfoResponse) GetLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Login
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserInfoResponse) GetNameSurname() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NameSurname
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserInfoResponse) GetAbout() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.About
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserInfoResponse) GetSpecializes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Specializes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UserInfoResponse) GetExecutor() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Executor
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UserInfoResponse) GetImg() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Img
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserInfoResponse) GetRating() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUserSpecializeResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Specializes []string `protobuf:"bytes,1,rep,name=specializes,proto3" json:"specializes,omitempty"`
}

func (x *GetUserSpecializeResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserSpecializeResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetUserSpecializeResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserSpecializeResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserSpecializeResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserSpecializeResponse.ProtoReflect.Descriptor instead.
func (*GetUserSpecializeResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{5}
}</span>

func (x *GetUserSpecializeResponse) GetSpecializes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Specializes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SetImgUrlRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id     uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        ImgIrl string `protobuf:"bytes,2,opt,name=imgIrl,proto3" json:"imgIrl,omitempty"`
        ReqId  uint64 `protobuf:"varint,3,opt,name=reqId,proto3" json:"reqId,omitempty"`
}

func (x *SetImgUrlRequest) Reset() <span class="cov0" title="0">{
        *x = SetImgUrlRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SetImgUrlRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SetImgUrlRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SetImgUrlRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SetImgUrlRequest.ProtoReflect.Descriptor instead.
func (*SetImgUrlRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{6}
}</span>

func (x *SetImgUrlRequest) GetId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SetImgUrlRequest) GetImgIrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ImgIrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SetImgUrlRequest) GetReqId() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReqId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type SetImgUrlResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Successfully bool `protobuf:"varint,1,opt,name=successfully,proto3" json:"successfully,omitempty"`
}

func (x *SetImgUrlResponse) Reset() <span class="cov0" title="0">{
        *x = SetImgUrlResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SetImgUrlResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SetImgUrlResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SetImgUrlResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SetImgUrlResponse.ProtoReflect.Descriptor instead.
func (*SetImgUrlResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{7}
}</span>

func (x *SetImgUrlResponse) GetSuccessfully() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Successfully
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_user_proto protoreflect.FileDescriptor

var file_user_proto_rawDesc = []byte{
        0x0a, 0x0a, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xc8, 0x01, 0x0a,
        0x0e, 0x4e, 0x65, 0x77, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
        0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x6e,
        0x61, 0x6d, 0x65, 0x53, 0x75, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0b, 0x6e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a,
        0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x61, 0x62, 0x6f,
        0x75, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x12,
        0x20, 0x0a, 0x0b, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x73, 0x18, 0x06,
        0x20, 0x03, 0x28, 0x09, 0x52, 0x0b, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x65,
        0x73, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x65, 0x71, 0x49, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04,
        0x52, 0x05, 0x72, 0x65, 0x71, 0x49, 0x64, 0x22, 0x3a, 0x0a, 0x0c, 0x55, 0x73, 0x65, 0x72, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x65, 0x78, 0x65, 0x63, 0x75,
        0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x65, 0x78, 0x65, 0x63, 0x75,
        0x74, 0x6f, 0x72, 0x22, 0x62, 0x0a, 0x18, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
        0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
        0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
        0x64, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x65, 0x71, 0x49, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04,
        0x52, 0x05, 0x72, 0x65, 0x71, 0x49, 0x64, 0x22, 0x33, 0x0a, 0x0b, 0x55, 0x73, 0x65, 0x72, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x04, 0x52, 0x02, 0x69, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x65, 0x71, 0x49, 0x64, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x05, 0x72, 0x65, 0x71, 0x49, 0x64, 0x22, 0xde, 0x01, 0x0a,
        0x10, 0x55, 0x73, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x20, 0x0a,
        0x0b, 0x6e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x0b, 0x6e, 0x61, 0x6d, 0x65, 0x53, 0x75, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12,
        0x14, 0x0a, 0x05, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
        0x61, 0x62, 0x6f, 0x75, 0x74, 0x12, 0x20, 0x0a, 0x0b, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c,
        0x69, 0x7a, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0b, 0x73, 0x70, 0x65, 0x63,
        0x69, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x65, 0x78, 0x65, 0x63, 0x75,
        0x74, 0x6f, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x65, 0x78, 0x65, 0x63, 0x75,
        0x74, 0x6f, 0x72, 0x12, 0x10, 0x0a, 0x03, 0x69, 0x6d, 0x67, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x03, 0x69, 0x6d, 0x67, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x18,
        0x08, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x72, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x22, 0x3d, 0x0a,
        0x19, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x53, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x69,
        0x7a, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x73, 0x70,
        0x65, 0x63, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52,
        0x0b, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x73, 0x22, 0x50, 0x0a, 0x10,
        0x53, 0x65, 0x74, 0x49, 0x6d, 0x67, 0x55, 0x72, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64,
        0x12, 0x16, 0x0a, 0x06, 0x69, 0x6d, 0x67, 0x49, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x06, 0x69, 0x6d, 0x67, 0x49, 0x72, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x65, 0x71, 0x49,
        0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x05, 0x72, 0x65, 0x71, 0x49, 0x64, 0x22, 0x37,
        0x0a, 0x11, 0x53, 0x65, 0x74, 0x49, 0x6d, 0x67, 0x55, 0x72, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75,
        0x6c, 0x6c, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x73, 0x75, 0x63, 0x63, 0x65,
        0x73, 0x73, 0x66, 0x75, 0x6c, 0x6c, 0x79, 0x32, 0xaa, 0x02, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72,
        0x12, 0x34, 0x0a, 0x10, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x55, 0x73, 0x65, 0x72, 0x12, 0x0f, 0x2e, 0x4e, 0x65, 0x77, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0d, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x3f, 0x0a, 0x11, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72,
        0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x55, 0x73, 0x65, 0x72, 0x12, 0x19, 0x2e, 0x41, 0x75,
        0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x55, 0x73, 0x65, 0x72, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0d, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x30, 0x0a, 0x0b, 0x47, 0x65, 0x74, 0x55, 0x73,
        0x65, 0x72, 0x42, 0x79, 0x49, 0x64, 0x12, 0x0c, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x11, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x43, 0x0a, 0x15, 0x47, 0x65, 0x74,
        0x53, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x42, 0x79, 0x55, 0x73, 0x65, 0x72,
        0x49, 0x64, 0x12, 0x0c, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x1a, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x53, 0x70, 0x65, 0x63, 0x69, 0x61,
        0x6c, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x34,
        0x0a, 0x09, 0x53, 0x65, 0x74, 0x49, 0x6d, 0x67, 0x55, 0x72, 0x6c, 0x12, 0x11, 0x2e, 0x53, 0x65,
        0x74, 0x49, 0x6d, 0x67, 0x55, 0x72, 0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x12,
        0x2e, 0x53, 0x65, 0x74, 0x49, 0x6d, 0x67, 0x55, 0x72, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x22, 0x00, 0x42, 0x07, 0x5a, 0x05, 0x2e, 0x2f, 0x61, 0x70, 0x69, 0x62, 0x06, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_user_proto_rawDescOnce sync.Once
        file_user_proto_rawDescData = file_user_proto_rawDesc
)

func file_user_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_user_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_user_proto_rawDescData = protoimpl.X.CompressGZIP(file_user_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_user_proto_rawDescData</span>
}

var file_user_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_user_proto_goTypes = []interface{}{
        (*NewUserRequest)(nil),            // 0: NewUserRequest
        (*UserResponse)(nil),              // 1: UserResponse
        (*AuthorizationUserRequest)(nil),  // 2: AuthorizationUserRequest
        (*UserRequest)(nil),               // 3: UserRequest
        (*UserInfoResponse)(nil),          // 4: UserInfoResponse
        (*GetUserSpecializeResponse)(nil), // 5: GetUserSpecializeResponse
        (*SetImgUrlRequest)(nil),          // 6: SetImgUrlRequest
        (*SetImgUrlResponse)(nil),         // 7: SetImgUrlResponse
}
var file_user_proto_depIdxs = []int32{
        0, // 0: User.RegistrationUser:input_type -&gt; NewUserRequest
        2, // 1: User.AuthorizationUser:input_type -&gt; AuthorizationUserRequest
        3, // 2: User.GetUserById:input_type -&gt; UserRequest
        3, // 3: User.GetSpecializeByUserId:input_type -&gt; UserRequest
        6, // 4: User.SetImgUrl:input_type -&gt; SetImgUrlRequest
        1, // 5: User.RegistrationUser:output_type -&gt; UserResponse
        1, // 6: User.AuthorizationUser:output_type -&gt; UserResponse
        4, // 7: User.GetUserById:output_type -&gt; UserInfoResponse
        5, // 8: User.GetSpecializeByUserId:output_type -&gt; GetUserSpecializeResponse
        7, // 9: User.SetImgUrl:output_type -&gt; SetImgUrlResponse
        5, // [5:10] is the sub-list for method output_type
        0, // [0:5] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_user_proto_init() }</span>
func file_user_proto_init() <span class="cov8" title="1">{
        if File_user_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_user_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*NewUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UserResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*AuthorizationUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UserInfoResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetUserSpecializeResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SetImgUrlRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SetImgUrlResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_user_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   8,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_user_proto_goTypes,
                DependencyIndexes: file_user_proto_depIdxs,
                MessageInfos:      file_user_proto_msgTypes,
        }.Build()
        File_user_proto = out.File
        file_user_proto_rawDesc = nil
        file_user_proto_goTypes = nil
        file_user_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package api

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
        RegistrationUser(ctx context.Context, in *NewUserRequest, opts ...grpc.CallOption) (*UserResponse, error)
        AuthorizationUser(ctx context.Context, in *AuthorizationUserRequest, opts ...grpc.CallOption) (*UserResponse, error)
        GetUserById(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UserInfoResponse, error)
        GetSpecializeByUserId(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*GetUserSpecializeResponse, error)
        SetImgUrl(ctx context.Context, in *SetImgUrlRequest, opts ...grpc.CallOption) (*SetImgUrlResponse, error)
}

type userClient struct {
        cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient <span class="cov0" title="0">{
        return &amp;userClient{cc}
}</span>

func (c *userClient) RegistrationUser(ctx context.Context, in *NewUserRequest, opts ...grpc.CallOption) (*UserResponse, error) <span class="cov0" title="0">{
        out := new(UserResponse)
        err := c.cc.Invoke(ctx, "/User/RegistrationUser", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userClient) AuthorizationUser(ctx context.Context, in *AuthorizationUserRequest, opts ...grpc.CallOption) (*UserResponse, error) <span class="cov0" title="0">{
        out := new(UserResponse)
        err := c.cc.Invoke(ctx, "/User/AuthorizationUser", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userClient) GetUserById(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UserInfoResponse, error) <span class="cov0" title="0">{
        out := new(UserInfoResponse)
        err := c.cc.Invoke(ctx, "/User/GetUserById", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userClient) GetSpecializeByUserId(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*GetUserSpecializeResponse, error) <span class="cov0" title="0">{
        out := new(GetUserSpecializeResponse)
        err := c.cc.Invoke(ctx, "/User/GetSpecializeByUserId", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userClient) SetImgUrl(ctx context.Context, in *SetImgUrlRequest, opts ...grpc.CallOption) (*SetImgUrlResponse, error) <span class="cov0" title="0">{
        out := new(SetImgUrlResponse)
        err := c.cc.Invoke(ctx, "/User/SetImgUrl", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
        RegistrationUser(context.Context, *NewUserRequest) (*UserResponse, error)
        AuthorizationUser(context.Context, *AuthorizationUserRequest) (*UserResponse, error)
        GetUserById(context.Context, *UserRequest) (*UserInfoResponse, error)
        GetSpecializeByUserId(context.Context, *UserRequest) (*GetUserSpecializeResponse, error)
        SetImgUrl(context.Context, *SetImgUrlRequest) (*SetImgUrlResponse, error)
        mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) RegistrationUser(context.Context, *NewUserRequest) (*UserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RegistrationUser not implemented")
}</span>
func (UnimplementedUserServer) AuthorizationUser(context.Context, *AuthorizationUserRequest) (*UserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AuthorizationUser not implemented")
}</span>
func (UnimplementedUserServer) GetUserById(context.Context, *UserRequest) (*UserInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserById not implemented")
}</span>
func (UnimplementedUserServer) GetSpecializeByUserId(context.Context, *UserRequest) (*GetUserSpecializeResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSpecializeByUserId not implemented")
}</span>
func (UnimplementedUserServer) SetImgUrl(context.Context, *SetImgUrlRequest) (*SetImgUrlResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SetImgUrl not implemented")
}</span>
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {<span class="cov0" title="0">}</span>

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
        mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;User_ServiceDesc, srv)
}</span>

func _User_RegistrationUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(NewUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServer).RegistrationUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/User/RegistrationUser",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServer).RegistrationUser(ctx, req.(*NewUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _User_AuthorizationUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AuthorizationUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServer).AuthorizationUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/User/AuthorizationUser",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServer).AuthorizationUser(ctx, req.(*AuthorizationUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _User_GetUserById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServer).GetUserById(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/User/GetUserById",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServer).GetUserById(ctx, req.(*UserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _User_GetSpecializeByUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServer).GetSpecializeByUserId(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/User/GetSpecializeByUserId",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServer).GetSpecializeByUserId(ctx, req.(*UserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _User_SetImgUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SetImgUrlRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServer).SetImgUrl(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/User/SetImgUrl",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServer).SetImgUrl(ctx, req.(*SetImgUrlRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "User",
        HandlerType: (*UserServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "RegistrationUser",
                        Handler:    _User_RegistrationUser_Handler,
                },
                {
                        MethodName: "AuthorizationUser",
                        Handler:    _User_AuthorizationUser_Handler,
                },
                {
                        MethodName: "GetUserById",
                        Handler:    _User_GetUserById_Handler,
                },
                {
                        MethodName: "GetSpecializeByUserId",
                        Handler:    _User_GetSpecializeByUserId_Handler,
                },
                {
                        MethodName: "SetImgUrl",
                        Handler:    _User_SetImgUrl_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "user.proto",
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "flag"
        "github.com/BurntSushi/toml"
        "github.com/gorilla/mux"
        "github.com/opentracing/opentracing-go"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/uber/jaeger-client-go"
        "github.com/uber/jaeger-lib/metrics"
        "google.golang.org/grpc"
        "net"
        "user/api"
        repository5 "user/internal/app/order/repository"
        repository4 "user/internal/app/review/repository"
        usecase4 "user/internal/app/review/usecase"
        handlers3 "user/internal/app/session/handlers"
        repository3 "user/internal/app/session/repository"
        usecase3 "user/internal/app/session/usecase"
        repository2 "user/internal/app/specialize/repository"
        usecase2 "user/internal/app/specialize/usecase"
        "user/internal/app/user/handlers"
        "user/internal/app/user/repository"
        "user/internal/app/user/usecase"
        "user/pkg/middleware"

        traceutils "github.com/opentracing-contrib/go-grpc"
        jaegercfg "github.com/uber/jaeger-client-go/config"
        jaegerlog "github.com/uber/jaeger-client-go/log"
        "log"
        "net/http"
        "user/configs"
        revHandler "user/internal/app/review/handlers"
        specHandler "user/internal/app/specialize/handler"
        "user/pkg/database/postgresql"
        "user/pkg/logger"
        pMetric "user/pkg/metric"
)

var (
        configPath string
)

func init() <span class="cov8" title="1">{
        flag.StringVar(&amp;configPath, "config-path", "configs/toml/server.toml", "path to config file")
}</span>

func main() <span class="cov0" title="0">{
        flag.Parse()
        config := configs.NewConfig()
        _, err := toml.DecodeFile(configPath, config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">if err = logger.InitLogger("stdout"); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">postgres, err := postgresql.NewPostgres(config.DSN)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := postgres.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }()

        <span class="cov0" title="0">jaegerCfgInstance := jaegercfg.Configuration{
                ServiceName: "UserService",
                Sampler: &amp;jaegercfg.SamplerConfig{
                        Type:  jaeger.SamplerTypeConst,
                        Param: 1,
                },
                Reporter: &amp;jaegercfg.ReporterConfig{
                        LogSpans:           true,
                        LocalAgentHostPort: "localhost:6831",
                },
        }

        tracer, closer, err := jaegerCfgInstance.NewTracer(
                jaegercfg.Logger(jaegerlog.StdLogger),
                jaegercfg.Metrics(metrics.NullFactory),
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("cannot create tracer", err)
        }</span>

        <span class="cov0" title="0">opentracing.SetGlobalTracer(tracer)
        defer closer.Close()

        userRepository := &amp;repository.Repository{
                Db: postgres.GetPostgres(),
        }
        specializeRepository := &amp;repository2.Repository{
                Db: postgres.GetPostgres(),
        }
        reviewRepository := &amp;repository4.Repository{
                Db: postgres.GetPostgres(),
        }

        //connect to auth service
        grpcConnAuth, err := grpc.Dial(
                ":8085",
                grpc.WithInsecure(),
                grpc.WithUnaryInterceptor(traceutils.OpenTracingClientInterceptor(tracer)),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("did not connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer grpcConnAuth.Close()

        //connect to order service
        grpcConnOrder, err := grpc.Dial(
                ":8086",
                grpc.WithInsecure(),
                grpc.WithUnaryInterceptor(traceutils.OpenTracingClientInterceptor(tracer)),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("did not connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer grpcConnOrder.Close()

        client := api.NewSessionClient(grpcConnAuth)
        sessionRepository := repository3.New(client)

        orderClient := api.NewOrderClient(grpcConnOrder)
        orderRepository := repository5.New(orderClient)

        userUseCase := usecase.New(userRepository, specializeRepository, reviewRepository)
        userHandler := handlers.New(userUseCase)

        specializeUseCase := usecase2.New(specializeRepository)
        specializeHandler := specHandler.New(specializeUseCase, userUseCase)

        sessionUseCase := usecase3.New(sessionRepository)
        sessionMiddleWare := handlers3.New(sessionUseCase)

        reviewUseCase := usecase4.New(reviewRepository, userRepository, orderRepository)
        reviewHandler := revHandler.New(reviewUseCase)
        csrfMiddleware := middleware.CSRFMiddleware(config.HTTPS)

        router := mux.NewRouter()
        router.Methods(http.MethodGet).Path("/metrics").Handler(promhttp.Handler())


        apiRoute := router.PathPrefix("/api").Subrouter()
        apiRoute.Use(middleware.LoggingRequest)
        apiRoute.Use(sessionMiddleWare.CheckSession)
        apiRoute.Use(csrfMiddleware)
        apiRoute.HandleFunc("/profile/{id:[0-9]+}", userHandler.GetUserInfo).Methods(http.MethodGet)
        apiRoute.HandleFunc("/profile/{id:[0-9]+}", userHandler.ChangeProfile).Methods(http.MethodPatch)
        apiRoute.HandleFunc("/profile/{id:[0-9]+}/specialize", specializeHandler.Create).Methods(http.MethodPost)
        apiRoute.HandleFunc("/profile/{id:[0-9]+}/specialize", specializeHandler.Remove).Methods(http.MethodDelete)

        apiRoute.HandleFunc("/profile/review", reviewHandler.Create).Methods(http.MethodPost)
        apiRoute.HandleFunc("/profile/{id:[0-9]+}/review", reviewHandler.GetAllByUserId).Methods(http.MethodGet)
        c := middleware.CorsMiddleware(config.Origin)
        pMetric.New()
        server := &amp;http.Server{
                Addr:    config.BindAddr,
                Handler: c.Handler(router),
        }
        go func() </span><span class="cov0" title="0">{
                if config.HTTPS </span><span class="cov0" title="0">{
                        log.Println("TLS server starting at port: ", server.Addr)
                        if err := server.ListenAndServeTLS(
                                "/etc/letsencrypt/live/findfreelancer.ru/cert.pem",
                                "/etc/letsencrypt/live/findfreelancer.ru/privkey.pem"); err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                }
                <span class="cov0" title="0">log.Println("Server start on port", config.BindAddr)
                if err := server.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }()

        <span class="cov0" title="0">s := grpc.NewServer(grpc.UnaryInterceptor(traceutils.OpenTracingServerInterceptor(tracer)))
        srv := handlers.NewGRPCServer(userUseCase)
        api.RegisterUserServer(s, srv)

        l, err := net.Listen("tcp", ":8081")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">log.Println("GRPC Server start on port :8081")
        if err := s.Serve(l); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package configs

type Config struct {
        BindAddr    string   `toml:"bind_addr"`
        LogLevel    string   `toml:"log_level"`
        DatabaseURL string   `toml:"database_url"`
        Origin      []string `toml:"origin"`
        ContentDir  string   `toml:"content_dir"`
        HTTPS       bool     `toml:"https"`
        DSN         string   `toml:"dsn"`
        LogFile     string   `toml:"log_file"`
}

func NewConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                BindAddr: ":8080",
                LogLevel: "debug",
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: user/internal/app/order (interfaces: Repository)

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"
        models "user/internal/app/models"

        gomock "github.com/golang/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov8" title="1">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// GetByID mocks base method.
func (m *MockRepository) GetByID(arg0 uint64, arg1 context.Context) (*models.OrderInfo, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", arg0, arg1)
        ret0, _ := ret[0].(*models.OrderInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockRepositoryMockRecorder) GetByID(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockRepository)(nil).GetByID), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package repository

import (
        "context"
        "user/api"
        "user/internal/app/models"
)

type Repository struct {
        client api.OrderClient
}

func New(client api.OrderClient) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                client: client,
        }
}</span>

func (r *Repository) GetByID(ID uint64, ctx context.Context) (*models.OrderInfo, error) <span class="cov0" title="0">{
        o, err := r.client.GetOrderById(ctx, &amp;api.OrderRequest{
                Id: ID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;models.OrderInfo{
                OrderName:   o.OrderName,
                CustomerId:  o.CustomerID,
                ExecutorId:  o.ExecutorID,
                Budget:      o.Budget,
                Description: o.Description,
                DeadLine:    o.Deadline,
                Category:    o.Category,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "encoding/json"
        "github.com/gorilla/mux"
        "net/http"
        "strconv"
        "user/internal/app/models"
        "user/internal/app/review"
        "user/pkg/httputils"
)

const (
        ctxKeyReqID uint8 = 1
)

type Handler struct {
        reviewsUseCase review.UseCase
}

func New(reviewsUseCase review.UseCase) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                reviewsUseCase: reviewsUseCase,
        }
}</span>

func (h *Handler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        reqID := r.Context().Value(ctxKeyReqID).(uint64)

        review := &amp;models.Review{}
        if err := json.NewDecoder(r.Body).Decode(review); err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r,reqID, err)
                return
        }</span>
        <span class="cov0" title="0">review, err := h.reviewsUseCase.Create(*review, r.Context())
        if err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r,reqID, err)
                return
        }</span>
        <span class="cov0" title="0">httputils.Respond(w, r,reqID, 200, review)</span>
}


func (h *Handler) GetAllByUserId(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        reqID := r.Context().Value(ctxKeyReqID).(uint64)

        params := mux.Vars(r)
        ID, err := strconv.ParseUint(params["id"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r,reqID, err)
                return
        }</span>

        <span class="cov0" title="0">reviews, err := h.reviewsUseCase.GetAllReviewByUserId(ID, r.Context())
        if err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r,reqID, err)
                return
        }</span>
        <span class="cov0" title="0">httputils.Respond(w, r,reqID, 200, reviews)</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: user/internal/app/review (interfaces: Repository)

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"
        models "user/internal/app/models"

        gomock "github.com/golang/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov8" title="1">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockRepository) Create(arg0 models.Review, arg1 context.Context) (*models.Review, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", arg0, arg1)
        ret0, _ := ret[0].(*models.Review)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockRepositoryMockRecorder) Create(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockRepository)(nil).Create), arg0, arg1)
}</span>

// GetAll mocks base method.
func (m *MockRepository) GetAll(arg0 uint64, arg1 context.Context) ([]models.Review, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll", arg0, arg1)
        ret0, _ := ret[0].([]models.Review)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockRepositoryMockRecorder) GetAll(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockRepository)(nil).GetAll), arg0, arg1)
}</span>

// GetAvgScoreByUserId mocks base method.
func (m *MockRepository) GetAvgScoreByUserId(arg0 uint64, arg1 context.Context) (*models.UserReviewInfo, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAvgScoreByUserId", arg0, arg1)
        ret0, _ := ret[0].(*models.UserReviewInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAvgScoreByUserId indicates an expected call of GetAvgScoreByUserId.
func (mr *MockRepositoryMockRecorder) GetAvgScoreByUserId(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAvgScoreByUserId", reflect.TypeOf((*MockRepository)(nil).GetAvgScoreByUserId), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package repository

import (
        "context"
        "github.com/jmoiron/sqlx"
        "github.com/pkg/errors"
        "user/internal/app/models"
        "user/pkg/error/errortools"
)

type Repository struct {
        Db *sqlx.DB
}

func (r *Repository) Create(review models.Review, ctx context.Context) (*models.Review, error) <span class="cov0" title="0">{
        var ID uint64
        err := r.Db.QueryRow(
                CreateReviewsRequest,
                review.UserId,
                review.ToUserId,
                review.OrderId,
                review.Description,
                review.Score).Scan(&amp;ID)
        if err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return nil, errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">review.ID = ID
        return &amp;review, nil</span>
}

func (r *Repository) GetAll(userId uint64, ctx context.Context) ([]models.Review, error) <span class="cov0" title="0">{
        var reviews []models.Review
        err := r.Db.Select(&amp;reviews, SelectAllReviewsByUseIDRequest, userId)
        if err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return nil, errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">return reviews, nil</span>
}

func (r *Repository) GetAvgScoreByUserId(userId uint64, ctx context.Context) (*models.UserReviewInfo, error) <span class="cov0" title="0">{
        userReviewInfo := &amp;models.UserReviewInfo{}
        err := r.Db.Get(userReviewInfo, SelectAvgScore, userId)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Unwrap(err).Error() == "converting NULL to uint8 is unsupported" </span><span class="cov0" title="0">{
                        return userReviewInfo, nil
                }</span>
                <span class="cov0" title="0">customErr := errortools.SqlErrorChoice(err)
                return nil, errors.Wrap(customErr, err.Error())</span>
        }
        <span class="cov0" title="0">return userReviewInfo, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package usecase

import (
        "context"
        "user/internal/app/models"
        "user/internal/app/order"
        "user/internal/app/review"
        "user/internal/app/user"
)

type UseCase struct {
        reviewRepository review.Repository
        userRepository   user.Repository
        orderRepository  order.Repository
}

func New(reviewRepository review.Repository, userRepository user.Repository, orderRepository order.Repository) *UseCase <span class="cov8" title="1">{
        return &amp;UseCase{
                reviewRepository: reviewRepository,
                userRepository: userRepository,
                orderRepository: orderRepository,
        }
}</span>

func (useCase *UseCase) Create(review models.Review, ctx context.Context) (*models.Review, error) <span class="cov8" title="1">{
        revResp, err := useCase.reviewRepository.Create(review, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return revResp, err</span>
}

func (useCase *UseCase) GetAllReviewByUserId(userId uint64, ctx context.Context) (*models.UserReviews, error) <span class="cov8" title="1">{
        reviews, err := useCase.reviewRepository.GetAll(userId, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for index, _ := range reviews </span><span class="cov8" title="1">{
                u, err := useCase.userRepository.FindUserByID(reviews[index].UserId, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">reviews[index].UserLogin = u.Login
                reviews[index].UserNameSurname = u.NameSurname
                oInf, err := useCase.orderRepository.GetByID(reviews[index].OrderId, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">reviews[index].OrderName = oInf.OrderName</span>
        }
        <span class="cov8" title="1">u, err := useCase.userRepository.FindUserByID(userId, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if reviews == nil </span><span class="cov0" title="0">{
                return &amp;models.UserReviews{
                        Name:    u.NameSurname,
                        Login:   u.Login,
                        Reviews: []models.Review{},
                }, nil
        }</span>
        <span class="cov8" title="1">return &amp;models.UserReviews{
                Name: u.NameSurname,
                Login: u.Login,
                Reviews: reviews,
        },nil</span>
}

</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "context"
        "net/http"
        "user/internal/app/session"
        "user/pkg/httputils"
)
const (
        ctxUserInfo uint8 = 2
        ctxKeyReqID uint8 = 1
)

type MidleWhare struct {
        sessionUseCase session.UseCase
}

func New(sessionUseCase session.UseCase) *MidleWhare <span class="cov0" title="0">{
        return &amp;MidleWhare{
                sessionUseCase: sessionUseCase,
        }
}</span>

func (m *MidleWhare) CheckSession(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                reqID := r.Context().Value(ctxKeyReqID).(uint64)

                sessionID, err := r.Cookie("sessionID")
                if err != nil </span><span class="cov0" title="0">{
                        httputils.RespondError(w, r, reqID, err,)
                        return
                }</span>

                <span class="cov0" title="0">u, err := m.sessionUseCase.Check(sessionID.Value, context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        httputils.RespondError(w, r, reqID, err,)
                        return
                }</span>
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), ctxUserInfo, u)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: user/internal/app/session (interfaces: Repository)

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"
        models "user/internal/app/models"

        gomock "github.com/golang/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov8" title="1">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Check mocks base method.
func (m *MockRepository) Check(arg0 string, arg1 context.Context) (*models.UserBasicInfo, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Check", arg0, arg1)
        ret0, _ := ret[0].(*models.UserBasicInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Check indicates an expected call of Check.
func (mr *MockRepositoryMockRecorder) Check(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Check", reflect.TypeOf((*MockRepository)(nil).Check), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package repository

import (
        "context"
        "time"
        "user/api"
        "user/internal/app/models"
)

type Repository struct {
        client api.SessionClient
}

func New(client api.SessionClient) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                client: client,
        }
}</span>

func (r *Repository) Check(sessionID string, ctx context.Context) (*models.UserBasicInfo, error) <span class="cov0" title="0">{
        timeOutCtx, cancel := context.WithTimeout(ctx, time.Second)
        defer cancel()
        u, err := r.client.Check(timeOutCtx, &amp;api.SessionCheckRequest{
                SessionId: sessionID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;models.UserBasicInfo{
                ID:       u.GetID(),
                Executor: u.Executor,
        }, err</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package usecase

import (
        "context"
        "user/internal/app/models"
        "user/internal/app/session"
)

type UseCase struct {
        sessionRepository session.Repository
}

func New(sessionRepository session.Repository) *UseCase <span class="cov0" title="0">{
        return &amp;UseCase{
                sessionRepository: sessionRepository,
        }
}</span>

func (useCase *UseCase) Check(sessionID string, ctx context.Context) (*models.UserBasicInfo, error) <span class="cov8" title="1">{
        u, err := useCase.sessionRepository.Check(sessionID, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return u, err</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handler

import (
        "context"
        "encoding/json"
        "github.com/gorilla/mux"
        "net/http"
        "strconv"
        "user/internal/app/models"
        "user/internal/app/specialize"
        "user/internal/app/user"
        "user/pkg/httputils"
)

const (
        ctxKeyReqID uint8 = 1
)

type Handler struct {
        specializeUseCase specialize.UseCase
        userUseCase       user.UseCase
}

func New(specializeUseCase specialize.UseCase, userUseCase user.UseCase) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                specializeUseCase: specializeUseCase,
                userUseCase: userUseCase,
        }
}</span>

func (h *Handler) Remove(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        reqID := r.Context().Value(ctxKeyReqID).(uint64)

        params := mux.Vars(r)
        id, err := strconv.ParseUint(params["id"], 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r, reqID, err)
                return
        }</span>
        <span class="cov0" title="0">s := &amp;models.Specialize{}
        if err := json.NewDecoder(r.Body).Decode(s); err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r, reqID, err)
                return
        }</span>
        <span class="cov0" title="0">err = h.specializeUseCase.Remove(id, s.Name, context.Background())
        if err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r, reqID, err)
                return
        }</span>
        <span class="cov0" title="0">httputils.Respond(w, r, reqID, 200, nil)</span>
}

func (h *Handler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        reqID := r.Context().Value(ctxKeyReqID).(uint64)

        params := mux.Vars(r)
        id, err := strconv.ParseUint(params["id"], 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r, reqID, err)
                return
        }</span>
        <span class="cov0" title="0">s := &amp;models.Specialize{}
        if err = json.NewDecoder(r.Body).Decode(s); err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r, reqID, err)
                return
        }</span>
        <span class="cov0" title="0">err = h.specializeUseCase.AssociateWithUser(id, s.Name, context.Background())
        if err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r, reqID, err)
                return
        }</span>
        <span class="cov0" title="0">u, err := h.userUseCase.GetById(id, context.Background())
        if err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r, reqID, err)
                return
        }</span>
        <span class="cov0" title="0">httputils.Respond(w, r, reqID, 200, u)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: user/internal/app/specialize (interfaces: Repository)

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        pq "github.com/lib/pq"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov8" title="1">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AssociateSpecializationWithUser mocks base method.
func (m *MockRepository) AssociateSpecializationWithUser(arg0, arg1 uint64, arg2 context.Context) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AssociateSpecializationWithUser", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// AssociateSpecializationWithUser indicates an expected call of AssociateSpecializationWithUser.
func (mr *MockRepositoryMockRecorder) AssociateSpecializationWithUser(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AssociateSpecializationWithUser", reflect.TypeOf((*MockRepository)(nil).AssociateSpecializationWithUser), arg0, arg1, arg2)
}</span>

// Create mocks base method.
func (m *MockRepository) Create(arg0 string, arg1 context.Context) (uint64, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", arg0, arg1)
        ret0, _ := ret[0].(uint64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockRepositoryMockRecorder) Create(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockRepository)(nil).Create), arg0, arg1)
}</span>

// FindByName mocks base method.
func (m *MockRepository) FindByName(arg0 string, arg1 context.Context) (uint64, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByName", arg0, arg1)
        ret0, _ := ret[0].(uint64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByName indicates an expected call of FindByName.
func (mr *MockRepositoryMockRecorder) FindByName(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByName", reflect.TypeOf((*MockRepository)(nil).FindByName), arg0, arg1)
}</span>

// FindByUserID mocks base method.
func (m *MockRepository) FindByUserID(arg0 uint64, arg1 context.Context) (pq.StringArray, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByUserID", arg0, arg1)
        ret0, _ := ret[0].(pq.StringArray)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByUserID indicates an expected call of FindByUserID.
func (mr *MockRepositoryMockRecorder) FindByUserID(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByUserID", reflect.TypeOf((*MockRepository)(nil).FindByUserID), arg0, arg1)
}</span>

// RemoveAssociateSpecializationWithUser mocks base method.
func (m *MockRepository) RemoveAssociateSpecializationWithUser(arg0, arg1 uint64, arg2 context.Context) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RemoveAssociateSpecializationWithUser", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RemoveAssociateSpecializationWithUser indicates an expected call of RemoveAssociateSpecializationWithUser.
func (mr *MockRepositoryMockRecorder) RemoveAssociateSpecializationWithUser(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveAssociateSpecializationWithUser", reflect.TypeOf((*MockRepository)(nil).RemoveAssociateSpecializationWithUser), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package repository

import (
        "context"
        "github.com/jmoiron/sqlx"
        "github.com/lib/pq"
        "github.com/pkg/errors"
        "strconv"
        "user/internal/app/models"
        "user/pkg/error/errortools"
)

type Repository struct {
        Db *sqlx.DB
}

func (r *Repository) FindByUserID(userID uint64, ctx context.Context) (pq.StringArray, error) <span class="cov0" title="0">{
        rows := r.Db.QueryRow(SelectSpecializesByUserID, userID)
        var specializes pq.StringArray
        if err := rows.Scan(&amp;specializes); err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return nil, errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">return specializes, nil</span>
}

func (r *Repository) Create(specialize string, ctx context.Context) (uint64, error) <span class="cov0" title="0">{
        var ID uint64 = 0
        err := r.Db.QueryRow(
                CreateSpecializeRequest, specialize).Scan(&amp;ID)
        if err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return 0, errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">return ID, nil</span>
}
//
//func (r *Repository) FindById(ID uint64, ctx context.Context) (string, error) {
//        spec := models.Specialize{}
//        err := r.Db.Get(&amp;spec, SelectSpecializesByID, ID)
//        if err != nil {
//                customErr := errortools.SqlErrorChoice(err)
//                return "", errors.Wrap(customErr, err.Error())
//        }
//        return spec.Name, nil
//}

func (r *Repository) FindByName(spec string, ctx context.Context) (uint64, error) <span class="cov0" title="0">{
        specialize := models.Specialize{}
        err := r.Db.Get(&amp;specialize, SelectSpecializesByName, spec)
        if err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return 0, errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">return specialize.ID, nil</span>
}

func (r *Repository) AssociateSpecializationWithUser(specId uint64, userId uint64, ctx context.Context) error <span class="cov0" title="0">{
        _, err := r.Db.NamedExec(
                CreateUserSpecializeRequest,
                map[string]interface{}{
                        "userID": strconv.FormatUint(userId, 10),
                        "specID": strconv.FormatUint(specId, 10),
                })
        if err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//func (r *Repository) Remove(ID uint64, ctx context.Context) error {
//        err := r.Db.QueryRow(DeleteSpecialize, ID).Err()
//        if err != nil {
//                customErr := errortools.SqlErrorChoice(err)
//                return errors.Wrap(customErr, err.Error())
//        }
//        return nil
//}

func (r *Repository)RemoveAssociateSpecializationWithUser(specId uint64, userId uint64, ctx context.Context) error<span class="cov0" title="0">{
        err := r.Db.QueryRow(DeleteAssociateSpecializeWithUser, userId, specId).Err()
        if err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package usecase

import (
        "context"
        "github.com/lib/pq"
        "github.com/pkg/errors"
        "user/internal/app/specialize"
)

type UseCase struct {
        specializeRepository specialize.Repository
}

func New(specializeRepository specialize.Repository) *UseCase <span class="cov8" title="1">{
        return &amp;UseCase{
                specializeRepository: specializeRepository,
        }
}</span>

func (useCase *UseCase) Create(specialize string, ctx context.Context) (uint64, error) <span class="cov8" title="1">{
        ID, err := useCase.specializeRepository.Create(specialize, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return ID, err</span>
}

func (useCase *UseCase) Remove(ID uint64, spec string, ctx context.Context) error <span class="cov8" title="1">{
        specID, err := useCase.specializeRepository.FindByName(spec, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = useCase.specializeRepository.RemoveAssociateSpecializationWithUser(specID, ID, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (useCase *UseCase) AssociateWithUser(ID uint64, spec string, ctx context.Context) error <span class="cov8" title="1">{
        specID, err := useCase.specializeRepository.FindByName(spec, ctx)
        if err != nil </span><span class="cov8" title="1">{
                specID, err = useCase.specializeRepository.Create(spec, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">err = useCase.specializeRepository.AssociateSpecializationWithUser(specID, ID, ctx)
        pqErr := &amp;pq.Error{}
        if errors.As(err, &amp;pqErr) </span><span class="cov8" title="1">{
                if pqErr.Code == "23505" </span><span class="cov8" title="1">{
                        return errors.New("Duplicate spec")
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "user/api"
        "user/internal/app/models"
        "user/internal/app/user"
        "user/pkg/error/errortools"
)

type GRPCServer struct {
        api.UnimplementedUserServer
        userUseCase user.UseCase
}

func NewGRPCServer(userUseCase user.UseCase) *GRPCServer <span class="cov0" title="0">{
        return &amp;GRPCServer{
                userUseCase: userUseCase,
        }
}</span>

func (s *GRPCServer) RegistrationUser(ctx context.Context, in *api.NewUserRequest) (*api.UserResponse, error) <span class="cov0" title="0">{
        u := &amp;models.NewUser{
                Email:       in.GetEmail(),
                Login:       in.GetLogin(),
                NameSurname: in.GetNameSurname(),
                Password:    in.GetPassword(),
                About:       in.GetAbout(),
                Specializes: in.GetSpecializes(),
        }

        answer, err := s.userUseCase.Create(u, ctx)
        if err != nil </span><span class="cov0" title="0">{
                errData, codeUint32 := errortools.ErrorHandle(err)
                code := codes.Code(codeUint32)
                b, jsonErr := json.Marshal(errData)
                if jsonErr != nil </span><span class="cov0" title="0">{
                        return nil, jsonErr
                }</span>
                <span class="cov0" title="0">return &amp;api.UserResponse{
                        Id:       0,
                        Executor: false,
                }, status.Error(code, string(b))</span>
        }

        <span class="cov0" title="0">return &amp;api.UserResponse{
                Id:      answer.ID,
                Executor: answer.Executor,
        }, nil</span>
}

func (s *GRPCServer) AuthorizationUser(ctx context.Context, in *api.AuthorizationUserRequest) (*api.UserResponse, error) <span class="cov0" title="0">{
        answer, err := s.userUseCase.Verification(in.GetEmail(), in.GetPassword(), ctx)
        if err != nil </span><span class="cov0" title="0">{
                errData, codeUint32 := errortools.ErrorHandle(err)
                code := codes.Code(codeUint32)
                serializeErrData, jsonErr := json.Marshal(errData)
                if jsonErr != nil </span><span class="cov0" title="0">{
                        return nil, jsonErr
                }</span>
                <span class="cov0" title="0">return &amp;api.UserResponse{
                        Id:       0,
                        Executor: false,
                }, status.Error(code, string(serializeErrData))</span>
        }
        <span class="cov0" title="0">return &amp;api.UserResponse{
                Id:      answer.ID,
                Executor: answer.Executor,
        }, nil</span>
}

func (s *GRPCServer) GetUserById(ctx context.Context, in *api.UserRequest) (*api.UserInfoResponse, error) <span class="cov0" title="0">{
        userInfo, err := s.userUseCase.GetById(in.GetId(), ctx)
        if err != nil </span><span class="cov0" title="0">{
                errData, codeUint32 := errortools.ErrorHandle(err)
                code := codes.Code(codeUint32)
                serializeErrData, jsonErr := json.Marshal(errData)
                if jsonErr != nil </span><span class="cov0" title="0">{
                        return nil, jsonErr
                }</span>
                <span class="cov0" title="0">return &amp;api.UserInfoResponse{
                        Email:       "",
                        Login:       "",
                        NameSurname: "",
                        About:       "",
                        Specializes: nil,
                        Executor:    false,
                        Img:         "",
                        Rating:      0,
                }, status.Error(code, string(serializeErrData))</span>
        }
        <span class="cov0" title="0">return &amp;api.UserInfoResponse{
                Email:       userInfo.Email,
                Login:       userInfo.Login,
                NameSurname: userInfo.NameSurname,
                About:       userInfo.About,
                Specializes: userInfo.Specializes,
                Executor:    userInfo.Executor,
                Img:         userInfo.Img,
                Rating:      int32(userInfo.Rating),
        }, nil</span>
}

func (s *GRPCServer) GetSpecializeByUserId(ctx context.Context, in *api.UserRequest) (*api.GetUserSpecializeResponse, error) <span class="cov0" title="0">{

        return nil, nil
}</span>

func (s *GRPCServer) SetImgUrl(ctx context.Context, in *api.SetImgUrlRequest) (*api.SetImgUrlResponse, error) <span class="cov0" title="0">{
        err := s.userUseCase.SetImg(in.GetId(), in.GetImgIrl(), ctx)
        if err != nil </span><span class="cov0" title="0">{
                errData, codeUint32 := errortools.ErrorHandle(err)
                code := codes.Code(codeUint32)
                serializeErrData, jsonErr := json.Marshal(errData)
                if jsonErr != nil </span><span class="cov0" title="0">{
                        return nil, jsonErr
                }</span>
                <span class="cov0" title="0">return &amp;api.SetImgUrlResponse{Successfully: false}, status.Error(code, string(serializeErrData))</span>
        }
        <span class="cov0" title="0">return &amp;api.SetImgUrlResponse{Successfully: true}, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package handlers

import (
        "encoding/json"
        "github.com/gorilla/mux"
        "golang.org/x/net/context"
        "net/http"
        "strconv"
        "user/internal/app/models"
        "user/internal/app/user"
        "user/pkg/httputils"
)

const (
        ctxKeyReqID uint8 = 1
)

type Handlers struct {
        userUseCase user.UseCase
}

func New(userUseCase user.UseCase) *Handlers <span class="cov0" title="0">{
        return &amp;Handlers{
                userUseCase: userUseCase,
        }
}</span>

func (h *Handlers) ChangeProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        reqID := r.Context().Value(ctxKeyReqID).(uint64)

        params := mux.Vars(r)
        id, err := strconv.ParseUint(params["id"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r, reqID, err)
                return
        }</span>
        <span class="cov0" title="0">u := &amp;models.ChangeUser{}
        if err := json.NewDecoder(r.Body).Decode(u); err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r, reqID, err)
                return
        }</span>
        <span class="cov0" title="0">u.ID = id
        response, err := h.userUseCase.Change(u, context.Background())
        if err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w,r, reqID, err)
                return
        }</span>
        <span class="cov0" title="0">httputils.Respond(w, r, reqID, http.StatusOK, response)</span>
}

func (h *Handlers) GetUserInfo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        reqID := r.Context().Value(ctxKeyReqID).(uint64)

        params := mux.Vars(r)
        ID, err := strconv.ParseUint(params["id"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r, reqID, err)
                return
        }</span>
        <span class="cov0" title="0">u, err := h.userUseCase.GetById(ID, context.Background())
        if err != nil </span><span class="cov0" title="0">{
                httputils.RespondError(w, r, reqID, err)
                return
        }</span>
        <span class="cov0" title="0">httputils.Respond(w, r, reqID, http.StatusOK, u)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: user/internal/app/user (interfaces: Repository)

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"
        models "user/internal/app/models"

        gomock "github.com/golang/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov8" title="1">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Change mocks base method.
func (m *MockRepository) Change(arg0 *models.ChangeUser, arg1 context.Context) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Change", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Change indicates an expected call of Change.
func (mr *MockRepositoryMockRecorder) Change(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Change", reflect.TypeOf((*MockRepository)(nil).Change), arg0, arg1)
}</span>

// Create mocks base method.
func (m *MockRepository) Create(arg0 *models.NewUser, arg1 context.Context) (uint64, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", arg0, arg1)
        ret0, _ := ret[0].(uint64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockRepositoryMockRecorder) Create(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockRepository)(nil).Create), arg0, arg1)
}</span>

// FindUserByEmail mocks base method.
func (m *MockRepository) FindUserByEmail(arg0 string, arg1 context.Context) (*models.UserInfo, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindUserByEmail", arg0, arg1)
        ret0, _ := ret[0].(*models.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindUserByEmail indicates an expected call of FindUserByEmail.
func (mr *MockRepositoryMockRecorder) FindUserByEmail(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUserByEmail", reflect.TypeOf((*MockRepository)(nil).FindUserByEmail), arg0, arg1)
}</span>

// FindUserByID mocks base method.
func (m *MockRepository) FindUserByID(arg0 uint64, arg1 context.Context) (*models.UserInfo, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindUserByID", arg0, arg1)
        ret0, _ := ret[0].(*models.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindUserByID indicates an expected call of FindUserByID.
func (mr *MockRepositoryMockRecorder) FindUserByID(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindUserByID", reflect.TypeOf((*MockRepository)(nil).FindUserByID), arg0, arg1)
}</span>

// SetUserImg mocks base method.
func (m *MockRepository) SetUserImg(arg0 uint64, arg1 string, arg2 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetUserImg", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SetUserImg indicates an expected call of SetUserImg.
func (mr *MockRepositoryMockRecorder) SetUserImg(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUserImg", reflect.TypeOf((*MockRepository)(nil).SetUserImg), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: user/internal/app/user (interfaces: UseCase)

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"
        models "user/internal/app/models"

        gomock "github.com/golang/mock/gomock"
)

// MockUseCase is a mock of UseCase interface.
type MockUseCase struct {
        ctrl     *gomock.Controller
        recorder *MockUseCaseMockRecorder
}

// MockUseCaseMockRecorder is the mock recorder for MockUseCase.
type MockUseCaseMockRecorder struct {
        mock *MockUseCase
}

// NewMockUseCase creates a new mock instance.
func NewMockUseCase(ctrl *gomock.Controller) *MockUseCase <span class="cov0" title="0">{
        mock := &amp;MockUseCase{ctrl: ctrl}
        mock.recorder = &amp;MockUseCaseMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUseCase) EXPECT() *MockUseCaseMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Change mocks base method.
func (m *MockUseCase) Change(arg0 *models.ChangeUser, arg1 context.Context) (*models.UserBasicInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Change", arg0, arg1)
        ret0, _ := ret[0].(*models.UserBasicInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Change indicates an expected call of Change.
func (mr *MockUseCaseMockRecorder) Change(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Change", reflect.TypeOf((*MockUseCase)(nil).Change), arg0, arg1)
}</span>

// Create mocks base method.
func (m *MockUseCase) Create(arg0 *models.NewUser, arg1 context.Context) (*models.UserBasicInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", arg0, arg1)
        ret0, _ := ret[0].(*models.UserBasicInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockUseCaseMockRecorder) Create(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUseCase)(nil).Create), arg0, arg1)
}</span>

// GetById mocks base method.
func (m *MockUseCase) GetById(arg0 uint64, arg1 context.Context) (*models.UserInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetById", arg0, arg1)
        ret0, _ := ret[0].(*models.UserInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetById indicates an expected call of GetById.
func (mr *MockUseCaseMockRecorder) GetById(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetById", reflect.TypeOf((*MockUseCase)(nil).GetById), arg0, arg1)
}</span>

// SetImg mocks base method.
func (m *MockUseCase) SetImg(arg0 uint64, arg1 string, arg2 context.Context) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetImg", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// SetImg indicates an expected call of SetImg.
func (mr *MockUseCaseMockRecorder) SetImg(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetImg", reflect.TypeOf((*MockUseCase)(nil).SetImg), arg0, arg1, arg2)
}</span>

// Verification mocks base method.
func (m *MockUseCase) Verification(arg0, arg1 string, arg2 context.Context) (*models.UserBasicInfo, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Verification", arg0, arg1, arg2)
        ret0, _ := ret[0].(*models.UserBasicInfo)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Verification indicates an expected call of Verification.
func (mr *MockUseCaseMockRecorder) Verification(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Verification", reflect.TypeOf((*MockUseCase)(nil).Verification), arg0, arg1, arg2)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package repository

import (
        "context"
        "github.com/jmoiron/sqlx"
        "github.com/pkg/errors"
        "user/internal/app/models"
        "user/pkg/error/errortools"
)

type Repository struct {
        Db *sqlx.DB
}

func (r *Repository) Create(user *models.NewUser, ctx context.Context) (uint64, error) <span class="cov0" title="0">{
        var ID uint64
        err := r.Db.QueryRow(
                CreateUserRequest,
                user.Email,
                user.EncryptPassword,
                user.Login,
                user.NameSurname,
                user.About,
                user.Executor).Scan(&amp;ID)
        if err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return 0, errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">return ID, nil</span>
}

func (r *Repository) Change(user *models.ChangeUser, ctx context.Context) error <span class="cov0" title="0">{
        tx := r.Db.MustBegin()
        _, err := tx.NamedExec(UpdateUser, user)
        if err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *Repository) FindUserByID(ID uint64, ctx context.Context) (*models.UserInfo, error) <span class="cov0" title="0">{
        user := models.UserInfo{}
        err := r.Db.Get(&amp;user, SelectUserByID, ID)
        if err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return nil, errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *Repository) FindUserByEmail(email string, ctx context.Context) (*models.UserInfo, error) <span class="cov0" title="0">{
        user := models.UserInfo{}
        err := r.Db.Get(&amp;user, SelectUserByEmail, email)
        if err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return nil, errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *Repository) SetUserImg(ID uint64, img string, ctx context.Context) error <span class="cov0" title="0">{
        err := r.Db.QueryRow(UpdateUserImg, img, ID).Err()
        if err != nil </span><span class="cov0" title="0">{
                customErr := errortools.SqlErrorChoice(err)
                return errors.Wrap(customErr, err.Error())
        }</span>
        <span class="cov0" title="0">return err</span>
}</pre>
		
		<pre class="file" id="file27" style="display: none">package tools

import (
        "bytes"
        "golang.org/x/crypto/argon2"
        "math/rand"
        "user/internal/app/models"
)

const (
        saltLength = 8
)

func CompPass(passHash []byte, plainPassword string) bool <span class="cov8" title="1">{
        salt := make([]byte, 8)
        copy(salt, passHash[0:8])

        userPassHash := hashPass(salt, plainPassword)
        return bytes.Equal(userPassHash, passHash)
}</span>

func BeforeCreate(user *models.NewUser) error <span class="cov8" title="1">{
        salt := make([]byte, saltLength)
        _, err := rand.Read(salt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">user.EncryptPassword = hashPass(salt, user.Password)
        if user.Specializes != nil </span><span class="cov8" title="1">{
                user.Executor = true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func BeforeChange(user *models.ChangeUser) error <span class="cov8" title="1">{
        salt := make([]byte, saltLength)
        _, err := rand.Read(salt)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">user.EncryptPassword = hashPass(salt, user.Password)
        if user.Specializes != nil </span><span class="cov8" title="1">{
                user.Executor = true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func hashPass(salt []byte, plainPassword string) []byte <span class="cov8" title="1">{
        hashedPass := argon2.IDKey([]byte(plainPassword), []byte(salt), 1, 64*1024, 4, 32)
        return append(salt, hashedPass...)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package tools

import (
        validation "github.com/go-ozzo/ozzo-validation"
        "github.com/go-ozzo/ozzo-validation/is"
        "user/internal/app/models"
)

const (
        minPasswordLength = 5
        maxPasswordLength = 30
)

func ValidationCreateUser(user *models.NewUser) error <span class="cov8" title="1">{
        err := validation.ValidateStruct(
                user,
                validation.Field(&amp;user.Email, validation.Required, is.Email),
                validation.Field(&amp;user.Password, validation.Required, validation.Length(minPasswordLength, maxPasswordLength)),
                validation.Field(&amp;user.Login, validation.Required),
                validation.Field(&amp;user.NameSurname, validation.Required),
        )
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ValidationChangeUser(user *models.ChangeUser) error <span class="cov8" title="1">{

        err := validation.ValidateStruct(
                user,
                validation.Field(&amp;user.Email, is.Email),
                validation.Field(&amp;user.Password, validation.Length(minPasswordLength, maxPasswordLength)),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file29" style="display: none">package usecase

import (
        "context"
        "github.com/pkg/errors"
        "user/internal/app/models"
        review2 "user/internal/app/review"
        specialize2 "user/internal/app/specialize"
        "user/internal/app/user"
        "user/internal/app/user/tools"
        customErrors "user/pkg/error"
)

type UseCase struct {
        userRepository       user.Repository
        specializeRepository specialize2.Repository
        reviewsRepository    review2.Repository
}

func (useCase *UseCase) SetImg(ID uint64, img string, ctx context.Context) error <span class="cov0" title="0">{
        err := useCase.userRepository.SetUserImg(ID, img, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (useCase *UseCase) Create(user *models.NewUser, ctx context.Context) (*models.UserBasicInfo, error) <span class="cov8" title="1">{
        if err := tools.ValidationCreateUser(user); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "Validation error")
        }</span>
        <span class="cov8" title="1">if err := tools.BeforeCreate(user); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Encrypt password error")
        }</span>
        <span class="cov8" title="1">ID, err := useCase.userRepository.Create(user, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Error in user repository.")
        }</span>

        <span class="cov8" title="1">for _, spec := range user.Specializes </span><span class="cov8" title="1">{
                specID, err := useCase.specializeRepository.FindByName(spec, ctx)
                if err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, customErrors.ErrorNoRows) </span><span class="cov8" title="1">{
                                specID, err = useCase.specializeRepository.Create(spec, ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, errors.Wrap(err, "Error in data sourse")
                                }</span>
                        }
                }
                <span class="cov8" title="1">err = useCase.specializeRepository.AssociateSpecializationWithUser(specID, ID, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return &amp;models.UserBasicInfo{
                ID:       ID,
                Executor: user.Executor,
        }, nil</span>
}

func (useCase *UseCase) Verification(email string, password string, ctx context.Context) (*models.UserBasicInfo, error) <span class="cov8" title="1">{
        user, err := useCase.userRepository.FindUserByEmail(email, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Error in user repository.")
        }</span>
        <span class="cov8" title="1">if !tools.CompPass(user.Password, password) </span><span class="cov8" title="1">{
                return nil, customErrors.ErrorInvalidPassword
        }</span>

        <span class="cov8" title="1">return &amp;models.UserBasicInfo{
                ID: user.ID,
                Executor: user.Executor,
        }, nil</span>
}

func (useCase *UseCase) GetById(ID uint64, ctx context.Context) (*models.UserInfo, error) <span class="cov8" title="1">{
        user, err := useCase.userRepository.FindUserByID(ID, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if user.Executor </span><span class="cov8" title="1">{
                user.Specializes, err = useCase.specializeRepository.FindByUserID(user.ID, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "Error in specialize repository.")
                }</span>
        }
        <span class="cov8" title="1">userReviewInfo, err := useCase.reviewsRepository.GetAvgScoreByUserId(ID, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">user.Rating = userReviewInfo.Rating
        user.ReviewCount = userReviewInfo.ReviewCount
        return user, nil</span>
}

func (useCase *UseCase) Change(user *models.ChangeUser, ctx context.Context) (*models.UserBasicInfo, error) <span class="cov8" title="1">{
        err := tools.ValidationChangeUser(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">oldUser, err := useCase.userRepository.FindUserByID(user.ID, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "User db error")
        }</span>

        <span class="cov8" title="1">if !tools.CompPass(oldUser.Password, user.Password) </span><span class="cov0" title="0">{
                return nil, customErrors.ErrorInvalidPassword
        }</span>
        <span class="cov8" title="1">if user.NewPassword != "" </span><span class="cov8" title="1">{
                user.Password = user.NewPassword
        }</span>
        <span class="cov8" title="1">if err := tools.BeforeChange(user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if user.Email == "" </span><span class="cov8" title="1">{
                user.Email = oldUser.Email
        }</span>

        <span class="cov8" title="1">if user.About == "" </span><span class="cov8" title="1">{
                user.About = oldUser.About
        }</span>

        <span class="cov8" title="1">if user.Password == "" </span><span class="cov0" title="0">{
                user.EncryptPassword = oldUser.Password
        }</span>

        <span class="cov8" title="1">if user.Login == "" </span><span class="cov8" title="1">{
                user.Login = oldUser.Login
        }</span>

        <span class="cov8" title="1">if user.NameSurname == "" </span><span class="cov8" title="1">{
                user.NameSurname = oldUser.NameSurname
        }</span>

        <span class="cov8" title="1">for _, spec := range oldUser.Specializes </span><span class="cov8" title="1">{
                user.Specializes = append(user.Specializes, spec)
        }</span>
        <span class="cov8" title="1">err = useCase.userRepository.Change(user, ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, spec := range user.Specializes </span><span class="cov8" title="1">{
                specID, err := useCase.specializeRepository.FindByName(spec, ctx)
                if err != nil </span><span class="cov8" title="1">{
                        if err == customErrors.ErrorNoRows </span><span class="cov8" title="1">{
                                specID, err = useCase.specializeRepository.Create(spec, ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, errors.Wrap(err, "Error in data sourse")
                                }</span>
                        }
                }
                <span class="cov8" title="1">err = useCase.specializeRepository.AssociateSpecializationWithUser(specID, oldUser.ID, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return         &amp;models.UserBasicInfo{
                ID: user.ID,
                Email: user.Email,
                About: user.About,
                Executor: user.Executor,
                Login: user.Login,
                NameSurname: user.NameSurname,
        }, nil</span>
}

func New(userRep user.Repository, specRep specialize2.Repository, reviewsRepository review2.Repository) *UseCase <span class="cov8" title="1">{
        return &amp;UseCase{
                specializeRepository: specRep,
                userRepository:       userRep,
                reviewsRepository:    reviewsRepository,
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package postgresql

import (
        "github.com/jmoiron/sqlx"
)

type Postgres struct {
        db *sqlx.DB
}

func NewPostgres(dsn string) (*Postgres, error) <span class="cov0" title="0">{
        db, err := sqlx.Connect("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Postgres{
                db: db,
        }, nil</span>
}

func (p *Postgres) GetPostgres() *sqlx.DB <span class="cov0" title="0">{
        return p.db
}</span>

func (p *Postgres) Close() error <span class="cov0" title="0">{
        err := p.db.Close()
        return err
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package errortools

import (
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "net/http"
        customError "user/pkg/error"
)

type grpcErrorInfo struct {
        Code codes.Code
        Handler func(error) (interface{}, int)
}



func grpcErrorHandle(err error)(interface{}, int, bool)<span class="cov0" title="0">{
        if grpcErr, ok := status.FromError(err); ok</span><span class="cov0" title="0">{
                if grpcErr.Code() &lt;= 16</span><span class="cov0" title="0">{
                        return map[string]string{
                                "message" : customError.InternalServerErrorMsg,
                        }, http.StatusInternalServerError, true
                }</span>
                <span class="cov0" title="0">return err.Error(), int(grpcErr.Code()), true</span>
        }
        <span class="cov0" title="0">return nil, 0, false</span>
}

</pre>
		
		<pre class="file" id="file32" style="display: none">package errortools

import (
        "database/sql"
        "github.com/lib/pq"
        "github.com/pkg/errors"

        "net/http"
        customError "user/pkg/error"
)

func SqlErrorChoice(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">pqErr := &amp;pq.Error{}
        if errors.As(err, &amp;pqErr) </span><span class="cov0" title="0">{
                if pqErr.Code == customError.PostgreDuplicateErrorCode </span><span class="cov0" title="0">{
                        return customError.ErrorDuplicate
                }</span>
        }
        <span class="cov0" title="0">if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                return customError.ErrorNoRows
        }</span>
        <span class="cov0" title="0">return customError.ErrorDataSource</span>
}

type sqlErrorInfo struct {
        Err     error
        Handler func(error) (map[string]interface{}, int)
}

func sqlErrorListCreate() []sqlErrorInfo <span class="cov0" title="0">{
        return []sqlErrorInfo{
                {Err: customError.ErrorNoRows, Handler: func(err error) (map[string]interface{}, int) </span><span class="cov0" title="0">{
                        return map[string]interface{}{
                                "message": "Source not found.",
                        }, http.StatusNotFound
                }</span>},
                {Err: customError.ErrorDataSource, Handler: func(err error) (map[string]interface{}, int) <span class="cov0" title="0">{
                        return map[string]interface{}{
                                "message": customError.InternalServerErrorMsg,
                        }, http.StatusInternalServerError
                }</span>},
                {Err: customError.ErrorDuplicate, Handler: func(err error) (map[string]interface{}, int) <span class="cov0" title="0">{
                        return map[string]interface{}{
                                "message": "This object already exists.",
                        }, http.StatusBadRequest
                }</span>},
        }
}

func sqlErrorHandle(err error) (map[string]interface{}, int, bool) <span class="cov0" title="0">{
        errorList := sqlErrorListCreate()
        for _, errorInfo := range errorList </span><span class="cov0" title="0">{
                if errors.Is(err, errorInfo.Err) </span><span class="cov0" title="0">{
                        data, code := errorInfo.Handler(err)
                        return data, code, true
                }</span>
        }
        <span class="cov0" title="0">return nil, 0, false</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package errortools

import (
        "github.com/pkg/errors"
        "net/http"
        customError "user/pkg/error"
)

func ErrorHandle(err error) (interface{}, int) <span class="cov0" title="0">{
        if errors.Is(err, customError.ErrorInvalidPassword) </span><span class="cov0" title="0">{
                return map[string]string{
                        "message": "Invalid password.",
                }, http.StatusBadRequest
        }</span>
        <span class="cov0" title="0">if respBody, code, ok := sqlErrorHandle(err); ok </span><span class="cov0" title="0">{
                return respBody, code
        }</span>
        <span class="cov0" title="0">if respBody, code, ok := validationErrorHandle(err); ok </span><span class="cov0" title="0">{
                return respBody, code
        }</span>
        <span class="cov0" title="0">if respBody, code, ok := grpcErrorHandle(err); ok </span><span class="cov0" title="0">{
                return respBody, code
        }</span>
        <span class="cov0" title="0">return map[string]interface{}{
                "message": customError.InternalServerErrorMsg,
        }, http.StatusInternalServerError</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package errortools

import (
        validation "github.com/go-ozzo/ozzo-validation"
        "github.com/pkg/errors"
        "net/http"
)


func validationErrorHandle(err error)(map[string]interface{}, int, bool)<span class="cov0" title="0">{
        validErr := validation.Errors{} //т.к это мэпа, по идее это уже указатель,&amp; не ставлю
        if errors.As(err, &amp;validErr)</span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "message" : validErr,
                }, http.StatusBadRequest, true
        }</span>
        <span class="cov0" title="0">return nil, 0, false</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package httputils

import (
        "encoding/json"
        "github.com/pkg/errors"
        "net/http"
        "user/pkg/error/errortools"
        "user/pkg/logger"
        "user/pkg/metric"
)

const (
        ctxKeyReqID uint8 = 1
)

func Respond(w http.ResponseWriter, r* http.Request, requestId uint64, code int, data interface{}) <span class="cov0" title="0">{
        w.WriteHeader(code)
        if data != nil </span><span class="cov0" title="0">{
                err := json.NewEncoder(w).Encode(data)
                if err != nil </span><span class="cov0" title="0">{
                        RespondError(w, r, requestId, err)
                        return
                }</span>
        }
        <span class="cov0" title="0">metric.CrateRequestHits(code, r)
        metric.CrateRequestTiming(r.Context(), r)
        logger.LoggingResponse(requestId, code)</span>
}

func RespondError(w http.ResponseWriter, r* http.Request, requestId uint64, err error) <span class="cov0" title="0">{
        logger.LoggingError(requestId, err)
        responseBody, code := errortools.ErrorHandle(err)
        metric.CrateRequestError(err)
        Respond(w, r, requestId, code, responseBody)
}</span>

func RespondCSRF() http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                reqID := r.Context().Value(ctxKeyReqID).(uint64)

                logger.LoggingError(reqID, errors.New("Invalid CSRF token"))
                Respond(w, r, reqID, http.StatusForbidden, map[string]interface{}{
                        "error": "Invalid CSRF token",
                })
        }</span>)
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package logger

import (
        log "github.com/sirupsen/logrus"
        "net/url"
        "os"
)

func InitLogger(stream string) error <span class="cov0" title="0">{
        if stream == "stdout" </span><span class="cov0" title="0">{
                log.SetOutput(os.Stdout)
        }</span> else<span class="cov0" title="0"> {
                logFileStream, err := os.Open(stream)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">log.SetOutput(logFileStream)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func LoggingRequest(reqID uint64, url *url.URL, method string) <span class="cov0" title="0">{
        log.WithFields(log.Fields{
                "request_id": reqID,
                "url":        url,
                "method":     method,
        }).Info()
}</span>

func LoggingResponse(reqID uint64, code int) <span class="cov0" title="0">{
        log.WithFields(log.Fields{
                "request_id": reqID,
                "reply_code": code,
        }).Info()
}</span>

func LoggingError(reqID uint64, err error) <span class="cov0" title="0">{
        log.WithFields(log.Fields{
                "request_id": reqID,
                "error":      err,
        }).Error()
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package metric

import (
        "context"
        "github.com/prometheus/client_golang/prometheus"
        "net/http"
        "strconv"
        "time"
)

const ctxKeyStartReqTime uint8 = 5

var (
        hits    *prometheus.CounterVec
        errors   *prometheus.CounterVec
        timings *prometheus.CounterVec
)

func New() <span class="cov0" title="0">{
        hits = prometheus.NewCounterVec(prometheus.CounterOpts{
                Name: "hits",
        }, []string{"status", "path"})
        errors = prometheus.NewCounterVec(prometheus.CounterOpts{
                Name: "errors",
        }, []string{"error"})
        timings = prometheus.NewCounterVec(prometheus.CounterOpts{
                Name: "timings",
        }, []string{"method", "URL", "time"})
        prometheus.MustRegister(hits, errors, timings)
}</span>

func CrateRequestTiming(ctx context.Context, r *http.Request) <span class="cov0" title="0">{
        timeStart := ctx.Value(ctxKeyStartReqTime).(time.Time)
        timings.WithLabelValues(r.Method, r.URL.String(), time.Since(timeStart).String()).Inc()
}</span>

func CrateRequestHits(status int, r *http.Request) <span class="cov0" title="0">{
        hits.WithLabelValues(strconv.Itoa(status), r.URL.Path).Inc()
}</span>

func  CrateRequestError(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                errors.WithLabelValues(err.Error()).Inc()
        }</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package middleware

import (
        "context"
        "github.com/gorilla/csrf"
        "github.com/rs/cors"
        "math/rand"
        "net/http"
        "time"
        "user/pkg/httputils"
        "user/pkg/logger"
)

const (
        ctxKeyReqID        uint8 = 1
        ctxKeyStartReqTime uint8 = 5
)

func LoggingRequest(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                reqID := rand.Uint64()
                logger.LoggingRequest(reqID, r.URL, r.Method)
                ctx := context.WithValue(r.Context(), ctxKeyStartReqTime, time.Now())
                next.ServeHTTP(w, r.WithContext(context.WithValue(ctx, ctxKeyReqID, reqID)))
        }</span>)
}

func CorsMiddleware(origin []string) *cors.Cors <span class="cov0" title="0">{
        return cors.New(cors.Options{
                AllowedOrigins:   origin,
                AllowedMethods:   []string{"POST", "GET", "OPTIONS", "PUT", "DELETE", "PATCH"},
                AllowedHeaders:   []string{"Content-Type", "X-Requested-With", "Accept", "X-Csrf-Token"},
                ExposedHeaders:   []string{"X-Csrf-Token"},
                AllowCredentials: true,
                MaxAge:           86400,
        })
}</span>

func CSRFMiddleware(https bool) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return csrf.Protect(
                []byte("very-secret-string"),
                csrf.SameSite(csrf.SameSiteLaxMode),
                csrf.Secure(https),
                csrf.MaxAge(900),
                csrf.Path("/"),
                csrf.ErrorHandler(httputils.RespondCSRF()))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
